---
layout: post
title:  "[자료구조] 해시 테이블(hash table)"
subtitle:   "자료구조 해시 테이블 정리"
categories: dev
tags: algorithm hash table
comments: false
---

## 개요
> 자료구조 `해시 테이블(hash table)`에 대한 정리글입니다.

- 목차
	- [해시 테이블(hash table)이란?](#해시-테이블hash-table이란) 
    - [해시 테이블 장단점](#해시-테이블-장단점)
    - [해시 테이블 충돌](#해시-테이블-충돌)
    - [시간 복잡도](#시간-복잡도)
    - [Python 해시 테이블 활용](#python-해시-테이블-활용)

## 해시 테이블(hash table)이란?
---

* __해시 테이블(hash table)__  
`키(Key)`와 `데이터(Value)`로 이루어진 구조로 키에 대한 데이터를 저장하는 자료 구조이다. 각각의 키 마다 데이터를 저장하고 있으므로 저장 공간은 많이 필요할 수 있지만 데이터를 찾는 속도는 매우 빠르게 유지할 수 있다.
> 파이썬에서 기본적으로 제공하고 있는 `딕셔너리(Dictionary)`는 해시 테이블의 예라고 할 수 있다.
해시 테이블은 저장, 삭제, 읽기가 빈번하고 검색이 많이 필요한 경우 사용된다.
> 중복 확인이 쉽기 때문에 캐쉬 구현시 사용된다.

* __해시 테이블 용어__  
  - 키(Key): 해싱 함수를 거치기 전 데이터. 본래 데이터 값
  - 해시 테이블(Hash Table): 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
  - 해싱 함수(Hashing Function): 효율적인 데이터 관리를 위해 임의의 데이터를 고정된 길이의 데이터로 변환해주는 함수
  - 해시 값(Hash Value), 해시(Hash) or 해시 주소(Hash Address): 해싱 함수로 연산되어 나온 데이터 값
  - 슬롯(Slot): 한 개의 데이터를 저장할 수 있는 공간(저장소)


## 해시 테이블 장단점
---
배열과 비교하여 해시 테이블에는 장단점이 있다. 상황에 따라 적절한 자료구조를 사용하면 된다.  

* __장점__  
  - 데이터 저장과 읽기 속도가 매우 빠르다.
  - 키 마다 데이터가 있으므로 중복 확인이 쉽다.

* __단점__  
  - 키 마다 데이터를 저장해야 하므로 저장공간이 많이 필요하다.
  - 해싱 함수로 배정된 해시 주소가 동일할 경우 충돌이 일어난다. (충돌 해결을 위한 대안이 필요)


## 해시 테이블 구현과 충돌
---
해시 테이블은 간단하게 해시 함수를 활용하여 구현할 수 있다. 데이터를 받아 각 데이터 마다 해시 함수를 활용하여 key를 설정하고, 해당 key 값에 적절하게 데이터를 저장하는 원리이다. 
하지만 여기서 고려해야할 점이 있다. 동일한 해시 주소에 다른 데이터가 저장될 경우 충돌이 발생하게 된다는 점이다. 저장해야할 데이터가 해시 테이블의 크기에 비해서 너무 많거나, 해시 함수에 따라 배정된 key가 중복된 상황이 발생한다면, 같은 주소에 데이터가 저장되는 `충돌 상황`이 발생한다.  
따라서, 충돌 상황을 피하기 위해서 기본적으로 해시 함수를 잘 설정해야하며, 데이터를 저장할 테이블의 크기를 적절하게 만들어줘야할 필요성이 있다.  
아무리 해시 함수를 잘 작성하고, 테이블의 크기를 조절한다고 해도 완벽하게 충돌을 피할 수 많은 없을 것이다. 그래서 해시 테이블의 충돌을 방지하는 방법으로 다음과 같이 대표적인 2가지 방법이 있다.  

* __Chaining기법__  
해시 테이블 저장공간 외의 공간을 활용하는 기법이다. 충돌이 일어나면, `링크드 리스트를 활용`하여 링크드 리스트로 데이터를 추가로 뒤에 연결시키는 방법이다.
충돌을 해결했지만, 링크드 리스트를 추가한 만큼 저장공간이 소모되며, 링크드 리스트를 탐색하는 동안엔 검색 속도가 해시 테이블에 비해 낮아진다.


* __Linear Probing기법__  
해시 테이블 저장공간 안에서 충돌 문제를 해결하는 기법이다. 충돌이 일어나면, 충돌이 일어난 주소의 다음 주소를 탐색하기 시작하여 맨 처음으로 나오는 빈 공간에 데이터를 저장한다.
추가적인 저장 공간 소모 없이 충돌을 해결했지만, 특정 주소값에 충돌이 몰릴 경우 저장과 검색의 효율성이 떨어질 수 있다.


해시 테이블의 원리와 구현, Chaining기법과 Linear Probing기법에 관한 상세한 내용은 [잔재미코딩](https://www.fun-coding.org/Chapter09-hashtable-live.html)을 참고하기 바란다. 해당 사이트에서는 상세한 설명과 코드가 포함되어 있어 해시 테이블을 이해하는데 큰 도움이 될 수 있다.



## 시간 복잡도
---
  - 해시 테이블에서 검색을 하는 경우 시간 복잡도는 어떻게 될까? 일반적인 경우는 Key값으로 데이터를 바로 조회할 수 있으므로 `O(1)`의 시간 복잡도를 갖는다.
  - 하지만, 충돌이 모두 발생하는 최악의 경우에는 데이터의 갯수만큼 조회해야하기 때문에 O(n)의 시간 복잡도를 갖는다.
 

 ## Python 해시 테이블 활용
---

* __해시 테이블을 사용하는 경우__  
해시 테이블의 장점을 떠올리면, 해시 테이블을 언제 사용하는게 좋을지 어느 정도 파악이 된다. 해시 테이블은 일반 리스트에 비해서 자료의 탐색이 시간 복잡도 O(1)로 매우 빠른 장점이 있다. 이 점으로 고려해 봤을 때, `데이터의 탐색이 빈번한 알고리즘`에서 활용도가 높다고 할 수 있다.  
가끔 인덱스를 통해 리스트의 자료에 접근하다가 `인덱스 외의 값으로도 데이터를 저장하고 꺼내고 싶다`는 생각이 들 때가 있다. 예를들면, 상품의 정보를 각각 상품명으로 조회하고 싶은 경우를 생각해보자. 상품명을 index로 하고, 상품과 관련된 정보를 value로 하여 해시 테이블에 저장한다면, 상품명만으로도 해당 상품과 관련된 정보에 쉽게 접근할 수 있을 것이다.
그 외에도 python에서는 `집계를 할 때` 해시 테이블을 활용할 수 있다. python의 collections 모듈의 Counter 클래스를 활용하면, 해당 리스트의 원소 개수를 해시 테이블 형태로 가공하여 return 받을 수 있다.

__Counter 활용 예제 코드__

```python
import collections
my_list = ['a', 'b', 'a', 'c']
count_my_list = dict(collections.Counter(my_list)) # {'a':2, 'b':1, 'c':1}
```

* __Python 해시 테이블 활용 방법__  
해시 테이블에 대해 알았다면, 이제 어떻게 해시 테이블을 사용하는지 알아야한다.  
python에서 해시 테이블은 dict 클래스로 구현되어 있다.

```python
# 딕셔너리 생성
my_dict = dict()
my_dict = {}

# 데이터 접근
my_dict['a']
my_dict.get('a',0) # get(key, x): dictionary에 key가 없는 경우 에러가 아닌, x를 return

# keys, values
my_dict.keys() # key만 return
my_dict.values() # value만 return
my_dict.items() # key-value 쌍으로 return

```