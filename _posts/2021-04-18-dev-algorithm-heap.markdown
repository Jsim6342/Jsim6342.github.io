---
layout: post
title:  "[자료구조] 힙(Heap)"
subtitle:   "자료구조 힙 정리"
categories: dev
tags: algorithm heap
comments: false
---

## 개요
> 자료구조 `힙(Heap)`에 대한 정리글입니다.

- 목차
	- [힙(Heap)이란?](#힙heap이란) 
    - [힙 구현](#힙-구현)
    - [힙의 시간 복잡도](#힙의-시간-복잡도)
    - [Python에서 힙 활용하기](#python에서-힙-활용하기)

## 힙(Heap)이란?
---

* __힙(Heap)__  
`최대값`과 `최소값`을 빠르게 찾기 위해 고안된 `완전 이진 트리`  
힙에는 최대값을 구하기 위한 `최대힙(Max Heap)`과 최소값을 구하기 위한 `최소힙(Min Heap)`이 있다.
> 완전 이진 트리(Complete Binary Tree): 노드를 삽입할 때 최하단 왼쪽 노드 부터 차례대로 삽입하는 트리

  - __힙 구조__  
  1. 각 노드의 값은 해당 노드의 자식 노드가 가진 값 보다 크거나 같다. (최대힙의 경우)  
  2. 완전 이진 트리 형태를 갖는다.


## 힙 구현
---
* __힙 동작__  
  - __삽입__  
  1) 힙은 완전 이진 트리의 구조 유지를 위해 삽입한 노드는 기본적으로 왼쪽 최하단부 노드 부터 순차적으로 채워지는 형태로 구현  
  2) 만약 채워진 노드가 부모 노드 보다 크다면(최대힙인 경우), 부모 노드와 자식 노드를 바꿔주는 작업을 반복해서 해준다.  
  ![이미지1](https://jsim6342.github.io/assets/img/anything/2021-04-18-dev-algorithm-heap-picture1.gif)

  - __삭제__  
  힙의 용도는 최대값, 최소값을 빠르게 구하기 위한 자료구조로 힙의 삭제는 보통 최상단 노드(root 노드)를 의미한다. (최상단 노드의 값을 삭제함과 동시에 반환한다.)  
  1) 힙의 최상단 노드를 삭제한다.  
  2) 삭제한 최상단 노드에 마지막에 위치한 노드를 넣는다.  
  3) 최소 or 최대힙의 구조가 구현되도록 자식 노드와 부모 노드를 비교하며 자리를 바꿔준다.  
  ![이미지2](https://jsim6342.github.io/assets/img/anything/2021-04-18-dev-algorithm-heap-picture2.gif)

* __배열을 활용한 힙 구현__  
완전 이진 트리 구조를 배열을 통해 구현할 수 있다. 힙 구현의 자세한 코드는 [잔재미코딩](https://www.fun-coding.org/Chapter11-heap.html)을 참고하기 바란다. 배열을 통해 힙을 구현할 때, 인덱스 번호의 배정은 다음과 같다.
> 부모 노드 인덱스 번호  = 자식 노드 인덱스 번호 // 2  
> 왼쪽 자식 노드 인덱스 번호 = 부모 노드 인덱스 번호 * 2  
> 오른쪽 자식 노드 인덱스 번호  = 부모 노드 인덱스 번호 * 2 + 1  


## 힙의 시간 복잡도
---
힙에서 데이터 삽입 또는 삭제 시, 최악의 경우엔 root 노드 부터 leaf 노드 까지 비교를 해야한다. 이진 트리의 특성상 logN 번의 비교를 해야하므로, 힙의 시간 복잡도는`O(logN)`이라고 할 수 있다.  
힙에 데이터를 넣고, 최대값과 최소값을 찾으면 O(logN) 이 걸리기 때문에, 일반 배열에 비해 매우 효율적이라고 할 수 있다.


## Python에서 힙 활용하기
---

* __힙을 사용하는 경우__    
힙의 가장 큰 특징은 최소값과 최대값을 언제든지 return 할 수 있다는 점이다.  
이러한 점에서 데이터의 `삽입과 삭제가 빈번한 상황`에서 `최소값과 최대값을 알아야할 때 활용`할 수 있다고 볼 수 있다.  


* __Python 힙 활용 방법__  
Python에서 힙을 구현하는 방법은 heapq 모듈과 Queue 모듈의 PriorityQueue 클래스를 통해 구현할 수 있다. (둘 모두 최소힙으로 구현)  
PriortyQueue는 클래스, heapq는 모듈이기 때문에 PriortyQueue를 사용하려면 객체 생성 후 메소드를 불러야 한다. 하지만, heapq의 경우는 객체 생성을 할 필요가 없으며, 모듈 내 함수를 호출하여 바로 heapq 형태로 정렬을 해주기 때문에 heapq가 더 빠르게 동작한다고 볼 수 있다.
따라서, 보통 Python에서는 힙을 구현할 때, `heapq 모듈`을 사용한다.

```python
import heapq # 힙 모듈

min_heap = [19, 30, 11, 7, 22]
heapq.heapify(min_heap) # 리스트를 힙 정렬. O(nlogn)
heapq.heappop(min_heap) # 맨 앞 최소(최대)값 pop. O(logn)
heapq.heappush(min_heap, 1) # 힙 정렬을 유지하면서 원소 추가. O(logn)

# 최대힙 만들기
# 최소힙에 (-item, item) 형태로 원소를 추가해주자.
data = [19, 30, 11, 7, 22]

max_heap = []
for item in data:
  heapq.heappush(max_heap, (-item, item))

```


## 참고

<https://ooeunz.tistory.com/7>