---
layout: post
title:  "[자료구조] 트리(Tree)"
subtitle:   "자료구조 트리 정리"
categories: dev
tags: algorithm tree
comments: false
---

## 개요
> 자료구조 `트리(Tree)`에 대한 정리글입니다.

- 목차
	- [트리(Tree)란?](#트리tree란) 
    - [이진 탐색 트리(Binary Search Tree)란?](#이진-탐색-트리binary-search-tree란)
    - [이진 탐색 트리 구현](#이진-탐색-트리-구현)
    - [이진 탐색 트리 시간 복잡도](#이진-탐색-트리-시간-복잡도)

## 트리(Tree)란?
---

* __트리(Tree)__  
자료구조 트리는 자료구조 그래프의 하위 범위로 `노드(Node)`와 `브랜치(Branch)`를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조이다.

* __트리 기본 구조, 용어__  
![이미지1](https://jsim6342.github.io/assets/img/dev/algorithm/2021-04-18-dev-algorithm-tree-picture1.png) 
  - __트리 용어__  
  Node: 트리에서 데이터를 저장하는 기본 요소로 데이터와 연결된 노드의 브랜치 정보 포함  
  Root Node: 트리 맨 위에 있는 노드  
  Level: 최상위 노드를 Level 0으로 했을 때, 하위 브랜치로 연결된 노드의 깊이  
  Parent Node: 부모 노드 (어떤 노드가 파생된 바로위 상위 레벨 노드)  
  Child Node: 자식 노드 (어떤 노드로 부터 파생된 바로 하위 레벨 노드)  
  Leaf Node(Terminal Node): Child Node가 하나도 없는 노드  
  Sibling (Brother Node): 동일한 Parent Node를 가진 노드  
  Depth: 트리에서 Node가 가질 수 있는 최대 Level  


## 이진 탐색 트리(Binary Search Tree)란?
---
자료 구조 트리는 특히 이진 트리 형태로 탐색 알고리즘 구현에 많이 활용된다.  
> 이진 트리: 노드의 최대 브랜치가 2인 트리  

* __이진 탐색 트리란?__  
이진 탐색 트리(BST)는 왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가지게 유지한 이진 트리 구조이다.  
이진 탐색이 기본적으로 구현된 자료구조로 데이터베이스 시스템이나 파일 시스템과 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용한다.  
큰 데이터를 처리하는 소프트웨어(ex. 데이터베이스 등)는 대부분 데이터를 트리 자료구조로 저장해서 이진탐색과 같은 탐색 기법을 이용해 빠르게 탐색이 가능하다.  

* __이진 탐색 트리의 장단점__  
이진 탐색 트리의 구조를 보면 이진 탐색 트리의 장단점에 대해서 쉽게 이해할 수 있다. 이진 탐색 트리는 부모 노드를 기준으로 왼쪽 노드는 작은 값, 오른쪽 노드는 큰 값을 유지한다. 다른 말로 말하자면, 찾고자 하는 데이터가 있을 때 `데이터의 범위를 절반씩 줄일 수 있다`는 것이다.  
하지만 장점만 있지는 않다. 이진 탐색 트리를 활용하기 위해서는 데이터의 삽입, 삭제가 발생하더라도 지속적으로 이진 탐색 트리의 구조가 유지시켜주는 작업을 해줘야 한다.  

  - 장점: 탐색 속도를 개선할 수 있어 `데이터 검색`에 효율적이다.  
  - 단점: 이진 탐색 트리를 유지시켜줘야 하며, 삭제 메서드가 비교적 복잡하다.


## 이진 탐색 트리 구현
---
이진 탐색 트리를 구현한다고 생각해보자. 크게 삽입, 삭제, 탐색 등의 기능이 있을 것이다. 여기서 삽입과 탐색에 대해서 생각해보면, 들어온 데이터의 대소를 비교하여 작으면 왼쪽 노드에, 크면 오른쪽 노드에 위치시켜주면 된다.  
문제는 삭제 기능이다. 삭제 기능에서는 여러 상황이 나누어지는데, 그만큼 삭제 메서드 코드를 짤 때 어려움을 겪을 수 있다. 따라서 삭제 기능에서 발생할 수 있는 다양한 상황을 나누어 생각해보며 기능을 구현해야 한다.  
삭제 기능을 구현했을 때 발생할 수 있는 여러 상황을 간략하게 요약하고, 상황에 맞게 어떻게 코드를 구현해야할지 구현 방향에 대해서도 요약해 보았다.  

![이미지2](https://jsim6342.github.io/assets/img/dev/algorithm/2021-04-18-dev-algorithm-tree-picture2.png) 


위의 원리를 바탕으로 구현한 코드는 [잔재미코딩](https://www.fun-coding.org/Chapter10-tree.html)을 참고하기 바란다.

* __Leaf Node삭제__  
삭제할 노드의 부모 노드가 삭제할 노드를 가리키지 않도록 한다.(None을 가리키도록 한다.)  

* __자식 노드가 1개인 노드 삭제__  
삭제할 노드의 부모 노드가 삭제할 노드의 자식 노드를 가리키도록 한다.  

* __자식 노드가 2개인 노드 삭제__  
자식 노드가 2개인 노드를 삭제하는 경우, 다음과 같은 2가지 방법이 있다. 두 방법 중에서 하나를 선택하여 구현한다.
> 1. 삭제할 노드의 오른쪽 자식 중에서 가장 작은 값을 삭제할 노드의 부모 노드가 가리키게함  
> 2. 삭제할 노드의 왼쪽 자식 중에서 가장 큰 값을 삭제할 노드의 부모 노드가 가리키게함


## 이진 탐색 트리 시간 복잡도
---
이진 탐색 트리는 한 level 마다 경우의 수가 절반씩 줄어드는 구조로 `O(logN)`의 시간 복잡도를 갖는다고 할 수 있다.  
하지만, 이는 이진 탐색 트리의 구조가 균형이 잡혀있을 때의 시간 복잡도이다. 만약, 이진 탐색 트리의 왼쪽이나 오른쪽으로 노드가 치우친 구조일 경우에는 효율성이 보다 떨어지게 되며, 최악의 경우에는 연결 리스트와 동일한 직선인 형태로 O(N)의 시간 복잡도를 갖는다.


## 참고

<https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html>