---
layout: post
title:  "[알고리즘] 그래프 탐색 알고리즘(DFS,BFS)"
subtitle:   "그래프 탐색 알고리즘 정리"
categories: dev
tags: algorithm dfs,bfs
use_math: False
comments: False
---

## 개요
> `그래프 탐색 알고리즘`에 대한 정리글입니다.

- 목차
	- [그래프 탐색](#그래프-탐색) 
    - [DFS와 BFS 구현](#dfs와-bfs-구현)
    - [DFS와 BFS의 시간 복잡도](#dfs와-bfs의-시간-복잡도)
    - [DFS와 BFS를 활용한 문제 풀이](#dfs와-bfs를-활용한-문제-풀이)


## 그래프 탐색
---

* __그래프 탐색이란?__  
그래프의 각 정점을 방문하는 것을 탐색이라고 한다. 탐색은 그래프에 관한 연산 중에서 중요한 연산으로 크게 `DFS(Depth-First Search)` 방법과 `BFS(Breadth-First Search)` 방법이 있다.
> 그래프: 정점(Node)와 그 정점을 연결하는 간선(Edge)로 이루어진 자료구조

* __깊이 우선 탐색(DFS, Depth-First Search)__  
정점의 자식들을 먼저 탐색하는 방식으로 최대한 깊이 내려가고, 더이상 갈 곳이 없을 경우에 옆으로 이동하여 탐색하는 방법이다.  
![이미지1](https://jsim6342.github.io/assets/img/dev/algorithm/2021-04-26-dev-algorithm-dfs,bfs-picture1.gif)

* __너비 우선 탐색(BFS, Breadth-First Search)__  
정점들과 같은 레벨에 있는 노드(형제 노드)들을 먼저 탐색하는 방식으로 최대한 넓게 이동하고, 더이상 갈 수 없을 때 아래로 이동하여 탐색하는 방법이다.  
![이미지2](https://jsim6342.github.io/assets/img/dev/algorithm/2021-04-26-dev-algorithm-dfs,bfs-picture2.gif)

## DFS와 BFS 구현
---

* __DFS 구현__  
DFS는 스택 또는 재귀함수를 활용하여 구현할 수 있다. 여기서는 스택을 활용하였다.  
방문 예정 노드를 저장하는 리스트가 스택의 역할을 한다. 방문 예정 노드에는 부모 노드로 부터 연결된 자식 노드들이 반복적으로 담기게 되는데, 자식 노드들이 부모 노드들 보다 우선적으로 pop 되면서 반복적으로 방문하게 되므로 DFS가 구현된다.  
자세한 DFS 구현 코드는 [잔재미코딩](https://www.fun-coding.org/Chapter18-dfs-live.html)을 참고하자.


* __BFS 구현__  
BFS는 큐를 활용하여 구현할 수 있다.  
DFS와 차이점은 방문 예정 노드 리스트를 큐로 동작시킨다는 점이다. 방문 예정 노드 리스트에는 차례대로 방문한 노드들과 연결된 노드들이 쌓이게 되고, 이 노드들이 차례대로 pop되면서 앞에 부모 노드 부터 pop되면서 부모 노드가 전부 pop되어야만 자식 노드가 pop될 수 있는 원리로 BFS가 구현된다. 
자세한 DFS 구현 코드는 [잔재미코딩](https://www.fun-coding.org/Chapter18-bfs-live.html)을 참고하자. 



## DFS와 BFS의 시간 복잡도
---
DFS와 BFS의 시간 복잡도는 조건 내 모든 노드를 검색한다는 점에서 동일하다고 볼 수 있다. 노드 수를 N, 간선 수를 E라고 했을 때, 위 코드에서 while문은 N + E 번 만큼 수행하게 된다. 따라서 시간 복잡도는 `O(N+E)`라고 볼 수 있다.



## DFS와 BFS를 활용한 문제 풀이
---
DFS와 BFS를 활용한 여러 알고리즘 문제들이 있다. 각 탐색의 특징에 따라 적합한 탐색 방법을 활용하여 문제 풀이에 적용하면 된다. 이 부분은 [튜나 개발일기](https://devuna.tistory.com/32 "블로그 이동") 블로그를 참고하여 작성하였다.  

* __그래프의 모든 정점을 방문하는 것이 주요 문제(완전 탐색)__  
DFS, BFS 모두 활용 가능  
> DFS, BFS 모두 모든 정점을 방문하므로 단순히 모든 정점을 방문하는 것이 주요 문제인 경우는 어느 알고리즘을 활용해도 된다.  

* __경로의 특징을 저장해둬야 하는 문제__  
DFS 활용  
> 각각의 경로 마다 특징을 저장해둬야 하는 문제는 DFS를 사용한다. 
> (BFS는 하나의 경로로 깊게 탐색하는 방식이 아니기 때문에 경로의 특징을 가지지 못한다.)  
> 이동할 때 마다 가중치가 붙어서 이동하는 문제  

* __최단거리를 구해야하는 문제__  
BFS 활용  
> 너비 우선 탐색으로 현재 노드에서 가까운 곳 부터 찾기 때문에, 경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리가 되기 때문이다. DFS의 경우는 각 루트를 끝까지 돌며 1개의 루트씩 탐색하기 때문에, 처음으로 발견되는 해답이 최단거리가 아닐 수 있다.  
> 미로 찾기 문제 등

* __그 밖에...__  
이동 과정에 여러 제약이 있을 경우: DFS  
검색 대상 그래프가 크다면: DFS  
검색 대상 규모가 작고, 시작 지점에서 대상이 가깝다면: BFS  

