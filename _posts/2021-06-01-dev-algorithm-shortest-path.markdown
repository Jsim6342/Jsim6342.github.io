---
layout: post
title:  "[알고리즘] 최단 경로 알고리즘"
subtitle:   "최단 경로 알고리즘 정리"
categories: dev
tags: algorithm shorttest path
use_math: False
comments: False
---

## 개요
> `최단 경로 알고리즘`에 대한 정리글입니다.

- 목차
	- [최단 경로 알고리즘](#최단-경로-알고리즘) 
    - [다익스트라 알고리즘](#다익스트라-알고리즘)
    - [플로이드 워셜 알고리즘](#플로이드-워셜-알고리즘)


## 최단 경로 알고리즘
---

* __최단 경로 알고리즘이란?__  
이름에서 알 수 있듯이, 말 그대로 가장 짧은 경로를 찾는 알고리즘으로 길 찾기 문제라고도 불린다. 최단 경로 알고리즘은 가장 짧은 경로를 찾거나, 최소 비용으로 길을 찾는 경우 등에 활용된다. 이를 조금 활용한다면, 최소 비용을 구해야 하는 다양한 문제에서도 최단 경로 알고리즘을 적용해 볼 수 있다.  
대표적으로 최단 경로 알고리즘에는 `다익스트라 알고리즘`과 `플로이드 워셜 알고리즘`이 있다. 두 알고리즘은 상황에 따라 각자 다르게 활용할 수 있다. 최단 경로 알고리즘은 다음과 같이 크게 2가지 상황으로 나뉜다.  
> 1. 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야하는 경우. (다익스트라).  
> 2. 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우. (플로이드 워셜)  


## 다익스트라 알고리즘
---

* __다익스트라 알고리즘이란?__  
그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다.  
출발 노드가 1개이므로 다른 모든 노드까지의 최단 거리를 `1차원 리스트`에 저장한다.  
즉, 다익스트라는 결과적으로 `특정 한 노드`에서 `다른 모든 노드`로의 최단거리를 구하는 알고리즘이다.  


* __다익스트라 알고리즘 원리__  
다익스트라 알고리즘은 연결되지 않는 노드 중에서 가장 비용이 적은 노드를 선택해 나간다는 점에서 `그리디 알고리즘`을 기반으로 동작한다. 다익스트라 알고리즘은 다음과 같다.  

> 1. 출발 노드를 설정  
> 2. 최단 거리 테이블을 초기화 → 무한으로 초기화 `1e9 활용`  
> 3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택 → `최소 힙 활용`  
> 4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신  
> 5. 3~4 과정을 반복  

일반적인 다익스트라 알고리즘은 3번 과정을 함수로 구현하여 시간 복잡도가 $O(V^2)$이다. 하지만, 개선된 다익스트라 알고리즘은 3번 과정을 최소 힙으로 구현하여 시간 복잡도를 $O(ElogV)$까지 향상시킬 수 있다. 따라서, 일반적으로 개선된 다익스트라를 알아두는 것이 좋다.  


* __다익스트라 구현__  
위의 원리를 바탕으로 구현한 개선된 다익스트라의 소스 코드이다. 다익스트라 알고리즘이 필요한 경우 해당 소스 코드를 참고하여 풀이하면 큰 도움이 될 수 있다. 해당 코드는 '이것이 코딩테스트다_나동빈'을 참고하여 작성하였다.  

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 10억으로 설정

# graph와 distance list는 index 자체를 노드번호로 해주기 위해 n + 1 크기로 해준다.
n, m = map(int, input().split()) # 노드, 간선 갯수 입력
start = int(input()) # 시작 노드 번호 입력
graph = [[] for _ in range(n + 1)] # 노드 정보 리스트 생성 (연결된 노드, 비용)을 의미
distance = [INF] * (n + 1) # 최단 거리 테이블 초기화

for _ in range(m):
	a, b, c = map(int, input().split())
	graph[a].append((b, c)) # a -> b, 비용 c

# 다익스트라 함수 구현
def dijkstra(start):
	q = []
	heapq.heappush(q, (0, start))
	distance[start] = 0
	while q:
		min_distance, now_node = heapq.heappop(q)
		if distance[now] < min_distance: # 현 노드가 이미 처리된 적이 있는 노드면 무시
			continue
		for near_node in graph[now_node]:
			cost = min_distance + near_node[1]
			if cost < distance[near_node[0]]:
				distance[near_node[0]] = cost
				heapq.heappush(q, (cost, near_node[0]))
	
dijkstra(start) # 다익스트라 알고리즘 수행

# 모든 노드로 가기 위한 최단거리 출력
for i in range(1, n + 1):
	if distance[i] == INF:
		print("INFINITY")
	else:
		print(distance[i])
```


## 플로이드 워셜 알고리즘
---

* __플로이드 워셜 알고리즘이란?__  
모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우에 사용할 수 있는 알고리즘이다.  
모든 노드에 대해 다른 모든 노드로 가는 정보를 담아야하기 때문에 `2차원 리스트`에 최단 거리를 저장.  
플로이드 워셜은 모든 지점에서 모든 지점까지의 최단 경로를 구하기 때문에 데이터가 비교적 적은 문제, 모든 경로의 최단 비용을 구할 수 있으므로 경유 문제 등에서 활용된다.  


* __플로이드 워셜 알고리즘 원리__  
플로이드 워셜 알고리즘은 다음 점화식에 따라 연결된 모든 노드 중에서 최소 비용을 2차원 리스트에 저장한다는 점에서 다이나믹 프로그래밍을 기반으로 한다고 볼 수 있다.  
다음 점화식은 a -> b와 a -> k -> b의 경로 중에서 최소값을 나타내는 점화식이다.  
$$D_ab = min(D_ab, D_ak + D_kb)$$

> 1. 연결된 그래프를 2차원 리스트로 표현한다. 
> 이 때, 연결된 간선은 그 값을 채우고, 자기 자신은 0, 연결되지 않은 간선은 INF(1e9)로 채운다.
> 2. 1번 노드 부터 순차적으로 거쳐가는 경우를 확인한다. 거쳐 가는 경우가 현재 2차원 리스트에 채워진 숫자보다 작다면, 그것으로 갱신해준다. 이 때, 위의 점화식을 활용한다.
> 3. 1번 노드 부터 N번 노드까지 2번 과정을 반복한다.

 플로이드 워셜 알고리즘은 1~N번 노드까지 거쳐가는 경우를 2차원 리스트 내에서 반복하므로 시간 복잡도는 $O(N^3)$으로 볼 수 있다.


* __플로이드 워셜 알고리즘 구현__  
위의 원리를 바탕으로 구현한 플로이드 워셜 알고리즘의 소스 코드이다. 플로이드 워셜 알고리즘이 필요한 경우 해당 소스 코드를 참고하여 풀이하면 큰 도움이 될 수 있다. 해당 코드는 '이것이 코딩테스트다_나동빈'을 참고하여 작성하였다.  

```python
INF = int(1e9)

n = int(input()) # 노드 개수
m - int(input()) # 간선 개수
graph = [[INF] * (n + 1) for _ in range(n + 1)] # 2차원 그래프 초기화

# 자기자신으로 가는 비용 0 초기화
for a in range(1, n + 1):
	for b in range(1, n + 1):
		if a == b:
			graph[a][b] = 0

# 각 간선에 대한 정보 입력
for _ in range(m):
	a, b, c = map(int, input().split()) # a -> b. 비용은 c로 설정
	graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘 수행
for k in range(1, n + 1):
	for a in range(1, n + 1):
		for b in range(1, n + 1):
			graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# 수행된 결과 출력
for a in range(1, n + 1):
	for b in range(1, n + 1):
		if graph[a][b] == INF:
			print("INFINITY", end=' ')
		else:
			print(graph[a][b], end=' ')
	print()
```


## 참고

책: '이것이 코딩 테스트다'_나동빈