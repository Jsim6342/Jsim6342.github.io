---
layout: post
title:  "[알고리즘] 다이나믹 프로그래밍"
subtitle:   "다이나믹 프로그래밍 정리"
categories: dev
tags: algorithm dp
use_math: true
comments: False
---

## 개요
> `다이나믹 프로그래밍`에 대한 정리글입니다.

- 목차
	- [다이나믹 프로그래밍](#다이나믹-프로그래밍) 
    - [다이나믹 프로그래밍 풀이법](#다이나믹-프로그래밍-풀이법)


## 다이나믹 프로그래밍
---

* __다이나믹 프로그래밍(DP)이란?__  
큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.  
다이나믹 프로그래밍은 알고리즘 문제 중에서 특히 수학적인 사고력을 많이 요구하기 때문에 코드의 구현력 보다는 문제를 해결하는 방향을 잡는 사고력이 중요하다고 볼 수 있다. 이런 점에서 고난이도 문제 유형에 속한다고 볼 수 있다.  


* __다이나믹 프로그래밍 사용 조건__  
어떤 문제를 보았을 때, 특별히 떠오르는 자료구조, 알고리즘이 없다면 다이나믹 프로그래밍을 의심해볼만 하다. 특히, 다이나믹 프로그래밍은 문제 안에서 `일정한 규칙`이 있어 `점화식`을 세울 수 있고, 이전 값들을 바탕으로 다음 값들을 도출할 수 있는 상황에서 활용된다.  
정리하자면, 다이나믹 프로그래밍을 사용하는 상황은 다음과 같다.  
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.


## 다이나믹 프로그래밍 풀이법
---

* __다이나믹 프로그래밍 풀이 방법__  
다이나믹 프로그래밍 문제는 큰 문제를 작은 문제로 나누고, 이 작은 문제들 간에 규칙을 찾아 점화식을 작성하여 풀이한다. 전체적인 풀이 과정은 다음과 같다.
> 1. 큰 문제를 작은 문제로 나눈다.  
> 2. 작은 문제들 간에 규칙을 찾는다.  
> 3. 규칙을 바탕으로 `점화식`을 작성한다.  
> → 점화식: 인접한 항들 사이의 관계식  
> 4. `탑다운 방식` or `바텀업 방식`을 활용하여 풀이한다.  


* __탑다운 방식(하향식)__  
큰 문제를 해결하기 위해 작은 문제를 호출하는 방법으로 `재귀함수`와 `메모이제이션` 기법을 활용하여 큰 문제에서 부터 파고들어 작은 문제를 구하는 방법이다. 
메모이제이션을 사용할 경우, 재귀함수는 곧 반복문과 유사한 시간 복잡도로 볼 수 있으므로 시간 복잡도는 약 `O(N)`이다.  
> 메모이제이션 기법(캐싱): 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법이다.
> 메모이제이션 기법의 구현은 한 번 구한 정보를 리스트 등에 저장하여 구현한다.


* __탑다운 방식 소스코드__  
탑다운 방식의 대표적인 코드는 다음과 같다. 다음 코드는 재귀 함수와 메모이제이션 기법을 활용한 피보나치 수열 풀이 코드이다. 코드는 '이것이 코딩테스트다_나동빈' 책을 참고하였다.

```python
array = [0] * 100 # 메모이제이션을 위한 리스트 초기화

def fibo(x):

	# 종료 조건
	if x == 1 or x == 2:
		return 1
	# 메모이제이션 리턴
	if array[x] != 0:
		return array[x]
	
	# 계산하지 않은 문제 계산
	array[x] = fibo(x-1) + fibo(x-2)
	return array[x]
```

* __바텀업 방식(상향식)__  
`반복문을 이용`하는 방법으로 작은 문제에서 부터 큰 문제로 해를 키워나가는 방법이다.  
탑다운 방식의 경우, 재귀함수의 복잡성과 깊이 오류 등을 신경써줘야 하기때문에, 좀 더 직관적인 바텀업 방식으로 다이나믹 프로그래밍을 풀이하는 것이 선호된다. 다이나믹 프로그래밍의 풀이는 전형적으로 바텀업 방식을 활용한다.  
점화식의 중간 값을 저장하는 결과 저장용 리스트는 `DP 테이블`이라고 부르며, 1차원 list를 만들어 구현한다.  
탑다운 방식과 마찬가지로, 바텀업 방식도 일반적으로 반복문을 1회 사용하기 때문에 시간 복잡도는 약 `O(N)`이다.


* __바텀업 방식 소스코드__  
바텀업 방식의 대표적인 코드는 다음과 같다. 다음 코드는 반복문과 dp테이블을 활용한 피보나치 수열 풀이 코드이다. 코드는 '이것이 코딩테스트다_나동빈' 책을 참고하였다.

```python
array = [0] * 100 # DP 테이블 초기화

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
array[1] = 1
array[2] = 1
n = 99

# 반복문 구현
for i in range(3, n + 1):
	array[i] = array[i-1] + array[i-2])
```


## 참고

책: '이것이 코딩 테스트다'_나동빈